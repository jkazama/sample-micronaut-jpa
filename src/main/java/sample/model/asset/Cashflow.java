package sample.model.asset;

import java.math.BigDecimal;
import java.time.*;
import java.util.List;

import javax.persistence.*;
import javax.validation.constraints.NotNull;

import lombok.*;
import sample.ActionStatusType;
import sample.ValidationException.ErrorKeys;
import sample.context.Dto;
import sample.context.orm.*;
import sample.model.asset.type.CashflowType;
import sample.model.constraints.*;
import sample.util.*;

/**
 * Account activity cashflow.
 * The cashflow is account activity information of the decision state generated by a cashflow action
 *  such as the transfer (without the request cancellation).
 * low: The minimum columns with this sample
 */
@Entity
@Data
@EqualsAndHashCode(callSuper = false)
public class Cashflow extends OrmActiveMetaRecord<Cashflow> {
    private static final long serialVersionUID = 1L;

    @Id
    @GeneratedValue
    private Long id;
    @IdStr
    private String accountId;
    @Currency
    private String currency;
    @Amount
    private BigDecimal amount;
    @NotNull
    @Enumerated(EnumType.STRING)
    private CashflowType cashflowType;
    @Category
    private String remark;
    @ISODate
    private LocalDate eventDay;
    @ISODateTime
    private LocalDateTime eventDate;
    @ISODate
    private LocalDate valueDay;
    @NotNull
    @Enumerated(EnumType.STRING)
    private ActionStatusType statusType;
    @ISODateTime
    private LocalDateTime createDate;
    @IdStr
    private String createId;
    @ISODateTime
    private LocalDateTime updateDate;
    @IdStr
    private String updateId;

    /** Make cashflow processed and reflect it to the balance. */
    public Cashflow realize(final OrmRepository rep) {
        validate((v) -> {
            v.verify(canRealize(rep), AssetErrorKeys.CashflowRealizeDay);
            v.verify(statusType.isUnprocessing(), ErrorKeys.ActionUnprocessing);
        });

        setStatusType(ActionStatusType.Processed);
        update(rep);
        CashBalance.getOrNew(rep, accountId, currency).add(rep, amount);
        return this;
    }

    /**
     * Mark error status.
     * low: Actually, Take error reasons in an argument and maintain it.
     */
    public Cashflow error(final OrmRepository rep) {
        validate((v) -> v.verify(statusType.isUnprocessed(), ErrorKeys.ActionUnprocessing));

        setStatusType(ActionStatusType.Error);
        return update(rep);
    }

    public boolean canRealize(final OrmRepository rep) {
        return rep.dh().time().tp().afterEqualsDay(valueDay);
    }

    public static Cashflow load(final OrmRepository rep, Long id) {
        return rep.load(Cashflow.class, id);
    }

    public static List<Cashflow> findUnrealize(final OrmRepository rep, String accountId, String currency,
            LocalDate valueDay) {
        return rep.tmpl().find(
                "from Cashflow c where c.accountId=?1 and c.currency=?2 and c.valueDay<=?3 and c.statusType in ?4 order by c.id",
                accountId, currency, valueDay, ActionStatusType.unprocessingTypes);
    }

    public static List<Cashflow> findDoRealize(final OrmRepository rep, LocalDate valueDay) {
        return rep.tmpl().find("from Cashflow c where c.valueDay=?1 and c.statusType in ?2 order by c.id", valueDay,
                ActionStatusType.unprocessedTypes);
    }

    /**
     * Register cashflow.
     * <p>Reached a value day, just reflect it to the balance.
     */
    public static Cashflow register(final OrmRepository rep, final RegCashflow p) {
        TimePoint now = rep.dh().time().tp();
        Validator.validate((v) -> v.checkField(now.beforeEqualsDay(p.getValueDay()),
                "valueDay", AssetErrorKeys.CashflowBeforeEqualsDay));
        Cashflow cf = p.create(now).save(rep);
        return cf.canRealize(rep) ? cf.realize(rep) : cf;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class RegCashflow implements Dto {
        private static final long serialVersionUID = 1L;
        @IdStr
        private String accountId;
        @Currency
        private String currency;
        @Amount
        private BigDecimal amount;
        @NotNull
        private CashflowType cashflowType;
        @Category
        private String remark;
        @ISODateEmpty
        private LocalDate eventDay;
        @ISODate
        private LocalDate valueDay;

        public Cashflow create(final TimePoint now) {
            TimePoint eventDate = eventDay == null ? now : new TimePoint(eventDay, now.getDate());
            Cashflow m = new Cashflow();
            m.setAccountId(accountId);
            m.setCurrency(currency);
            m.setAmount(amount);
            m.setCashflowType(cashflowType);
            m.setRemark(remark);
            m.setEventDay(eventDate.getDay());
            m.setEventDate(eventDate.getDate());
            m.setValueDay(valueDay);
            m.setStatusType(ActionStatusType.Unprocessed);
            return m;
        }
    }

}
